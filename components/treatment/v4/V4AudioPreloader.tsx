'use client';

import { useEffect } from 'react';
import { globalAudioCache } from '@/services/voice/audioCache';
import { V4_STATIC_AUDIO_TEXTS } from '@/lib/v4/static-audio-texts';

/**
 * V4 Audio Preloader - Static File Version (Multi-Voice Support)
 * 
 * Preloads all static audio segments for v4 treatment sessions from pre-generated files.
 * This eliminates the need for TTS API calls, reducing costs to $0.
 * 
 * How it works:
 * 1. Audio files are pre-generated once per voice using scripts/generate-static-audio.js
 * 2. Files are stored in public/audio/v4/static/[voice-name]/
 * 3. This component loads the manifest for the selected voice and preloads the files
 * 4. Users download static MP3 files (no API calls = no cost)
 * 
 * Cost: $0 per user (vs ~10,000 credits per user with dynamic generation)
 */

// Manifest will be loaded from public/audio/v4/static/[voice]/manifest.json
// Generated by scripts/generate-static-audio.js [voice-name]
type AudioManifest = {
  [key: string]: {
    filename: string;
    hash: string;
    path: string;
  };
};

interface V4AudioPreloaderProps {
  voice?: string; // 'rachel' | 'adam' etc.
}

export default function V4AudioPreloader({ voice = 'rachel' }: V4AudioPreloaderProps) {
  useEffect(() => {
    const preloadStaticAudio = async () => {
      let successCount = 0;
      let skipCount = 0;
      let failCount = 0;

      console.log(`üéµ V4: Starting audio preload for voice "${voice}" from static files...`);

      try {
        // Load the manifest for the selected voice
        const manifestResponse = await fetch(`/audio/v4/static/${voice}/manifest.json`);
        
        if (!manifestResponse.ok) {
          console.error(`‚ùå Static audio manifest not found for voice "${voice}". Audio preloading disabled.`);
          console.error('   To fix this:');
          console.error(`   1. Run: ELEVENLABS_API_KEY=xxx node scripts/generate-static-audio.js ${voice}`);
          console.error('   2. Commit the generated files');
          console.error('   3. Redeploy');
          // No fallback to dynamic TTS - prevents accidental API charges
          return;
        }

        const manifest: AudioManifest = await manifestResponse.json();
        const manifestKeys = Object.keys(manifest);

        console.log(`üìã Loaded manifest for "${voice}" with ${manifestKeys.length} audio files`);

        // Preload each audio file (skip INITIAL_WELCOME - it's short enough to generate on-demand)
        for (const [key, audioInfo] of Object.entries(manifest)) {
          // Skip INITIAL_WELCOME to save initial load time (it's now very short)
          if (key === 'INITIAL_WELCOME') {
            skipCount++;
            console.log(`   ‚è≠Ô∏è  Skipped: INITIAL_WELCOME (will generate on-demand if needed)`);
            continue;
          }

          const text = V4_STATIC_AUDIO_TEXTS[key as keyof typeof V4_STATIC_AUDIO_TEXTS];
          
          if (!text) {
            console.warn(`‚ö†Ô∏è Unknown key in manifest: ${key}`);
            continue;
          }

          // Use voice-prefixed cache key to support multiple voices
          const cacheKey = `${voice}:${text}`;

          // Skip if already in cache
          if (globalAudioCache.has(cacheKey)) {
            skipCount++;
            continue;
          }

          try {
            // Fetch the static audio file
            const audioResponse = await fetch(audioInfo.path);
            
            if (!audioResponse.ok) {
              throw new Error(`Failed to load ${audioInfo.filename}: ${audioResponse.status}`);
            }

            const audioBlob = await audioResponse.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            globalAudioCache.set(cacheKey, audioUrl);
            successCount++;
            
            // Log preview of what was cached
            const preview = text.substring(0, 50).replace(/\n/g, ' ');
            const ellipsis = text.length > 50 ? '...' : '';
            console.log(`   ‚úì Cached: "${preview}${ellipsis}"`);
          } catch (err) {
            failCount++;
            const preview = text.substring(0, 50).replace(/\n/g, ' ');
            console.error(`   ‚úó Failed: "${preview}..."`, err);
          }
        }

        console.log(`‚úÖ V4 Audio preload complete for "${voice}"!`);
        console.log(`   Successfully cached: ${successCount} segment(s)`);
        console.log(`   Already cached: ${skipCount} segment(s)`);
        console.log(`   Failed: ${failCount} segment(s)`);
        console.log(`   Total cache size: ${globalAudioCache.size()} audio file(s)`);
        console.log(`   üí∞ Cost: $0 (using static files)`);
      } catch (err) {
        console.error('‚ùå Failed to load audio manifest:', err);
        console.error('   Audio preloading disabled - no dynamic TTS fallback (prevents charges)');
        // No fallback to dynamic TTS - prevents accidental API charges
      }
    };

    // Start preloading (static files only - no API fallback)
    // Note: Using voice-prefixed cache keys allows multiple voices to be cached simultaneously
    preloadStaticAudio();
  }, [voice]); // Re-run when voice changes

  // This component doesn't render anything
  return null;
}
