'use client';

import { useEffect } from 'react';
import { globalAudioCache } from '@/services/voice/audioCache';
import { V4_STATIC_AUDIO_TEXTS } from '@/lib/v4/static-audio-texts';

/**
 * V4 Audio Preloader - Static File Version
 * 
 * Preloads all static audio segments for v4 treatment sessions from pre-generated files.
 * This eliminates the need for TTS API calls, reducing costs to $0.
 * 
 * How it works:
 * 1. Audio files are pre-generated once using scripts/generate-static-audio.js
 * 2. Files are stored in public/audio/v4/static/
 * 3. This component loads the manifest and preloads the files
 * 4. Users download static MP3 files (no API calls = no cost)
 * 
 * Cost: $0 per user (vs ~10,000 credits per user with dynamic generation)
 */

// Manifest will be loaded from public/audio/v4/static/manifest.json
// Generated by scripts/generate-static-audio.js
type AudioManifest = {
  [key: string]: {
    filename: string;
    hash: string;
    path: string;
  };
};

export default function V4AudioPreloader() {
  useEffect(() => {
    const preloadStaticAudio = async () => {
      let successCount = 0;
      let skipCount = 0;
      let failCount = 0;

      console.log(`ðŸŽµ V4: Starting audio preload from static files...`);

      try {
        // Load the manifest
        const manifestResponse = await fetch('/audio/v4/static/manifest.json');
        
        if (!manifestResponse.ok) {
          console.warn('âš ï¸ Static audio manifest not found. Falling back to dynamic TTS.');
          console.warn('   To use static audio:');
          console.warn('   1. Run: node scripts/generate-static-audio.js');
          console.warn('   2. Commit the generated files');
          console.warn('   3. Redeploy');
          // Fallback to old behavior
          await preloadDynamicAudio();
          return;
        }

        const manifest: AudioManifest = await manifestResponse.json();
        const manifestKeys = Object.keys(manifest);

        console.log(`ðŸ“‹ Loaded manifest with ${manifestKeys.length} audio files`);

        // Preload each audio file
        for (const [key, audioInfo] of Object.entries(manifest)) {
          const text = V4_STATIC_AUDIO_TEXTS[key as keyof typeof V4_STATIC_AUDIO_TEXTS];
          
          if (!text) {
            console.warn(`âš ï¸ Unknown key in manifest: ${key}`);
            continue;
          }

          // Skip if already in cache
          if (globalAudioCache.has(text)) {
            skipCount++;
            continue;
          }

          try {
            // Fetch the static audio file
            const audioResponse = await fetch(audioInfo.path);
            
            if (!audioResponse.ok) {
              throw new Error(`Failed to load ${audioInfo.filename}: ${audioResponse.status}`);
            }

            const audioBlob = await audioResponse.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            globalAudioCache.set(text, audioUrl);
            successCount++;
            
            // Log preview of what was cached
            const preview = text.substring(0, 50).replace(/\n/g, ' ');
            const ellipsis = text.length > 50 ? '...' : '';
            console.log(`   âœ“ Cached: "${preview}${ellipsis}"`);
          } catch (err) {
            failCount++;
            const preview = text.substring(0, 50).replace(/\n/g, ' ');
            console.error(`   âœ— Failed: "${preview}..."`, err);
          }
        }

        console.log(`âœ… V4 Audio preload complete!`);
        console.log(`   Successfully cached: ${successCount} segment(s)`);
        console.log(`   Already cached: ${skipCount} segment(s)`);
        console.log(`   Failed: ${failCount} segment(s)`);
        console.log(`   Total cache size: ${globalAudioCache.size()} audio file(s)`);
        console.log(`   ðŸ’° Cost: $0 (using static files)`);
      } catch (err) {
        console.error('âŒ Failed to load audio manifest:', err);
        console.warn('   Falling back to dynamic TTS (will incur API costs)');
        await preloadDynamicAudio();
      }
    };

    /**
     * Fallback to dynamic TTS generation if static files aren't available
     * This is the old behavior - kept for backwards compatibility
     */
    const preloadDynamicAudio = async () => {
      const textsToPreload = Object.values(V4_STATIC_AUDIO_TEXTS);
      let successCount = 0;
      let skipCount = 0;
      let failCount = 0;

      console.log(`ðŸŽµ V4: Using dynamic TTS (will incur API costs)`);
      console.log(`   Preloading ${textsToPreload.length} segments...`);

      for (const text of textsToPreload) {
        if (globalAudioCache.has(text)) {
          skipCount++;
          continue;
        }

        try {
          const response = await fetch('/api/tts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              text,
              provider: 'elevenlabs',
              voice: '21m00Tcm4TlvDq8ikWAM', // Rachel
            }),
          });

          if (!response.ok) {
            throw new Error(`TTS request failed: ${response.status}`);
          }

          const audioBlob = await response.blob();
          const audioUrl = URL.createObjectURL(audioBlob);
          globalAudioCache.set(text, audioUrl);
          successCount++;
          
          const preview = text.substring(0, 50).replace(/\n/g, ' ') + '...';
          console.log(`   âœ“ Cached: "${preview}"`);
        } catch (err) {
          failCount++;
          const preview = text.substring(0, 50).replace(/\n/g, ' ') + '...';
          console.error(`   âœ— Failed: "${preview}"`, err);
        }
      }

      console.log(`âœ… V4 Audio preload complete!`);
      console.log(`   Successfully cached: ${successCount} segment(s)`);
      console.log(`   Already cached: ${skipCount} segment(s)`);
      console.log(`   Failed: ${failCount} segment(s)`);
      console.log(`   ðŸ’° Cost: ~${successCount * 632} credits`);
    };

    // Start preloading
    preloadStaticAudio();
  }, []); // Empty deps = runs once on mount

  // This component doesn't render anything
  return null;
}

