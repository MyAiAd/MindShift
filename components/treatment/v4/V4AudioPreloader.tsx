'use client';

import { useEffect } from 'react';
import { globalAudioCache } from '@/services/voice/audioCache';
import { V4_STATIC_AUDIO_TEXTS } from '@/lib/v4/static-audio-texts';

/**
 * V4 Audio Preloader - Static File Version
 * 
 * Preloads all static audio segments for v4 treatment sessions from pre-generated files.
 * This eliminates the need for TTS API calls, reducing costs to $0.
 * 
 * How it works:
 * 1. Audio files are pre-generated once using scripts/generate-static-audio.js
 * 2. Files are stored in public/audio/v4/static/
 * 3. This component loads the manifest and preloads the files
 * 4. Users download static MP3 files (no API calls = no cost)
 * 
 * Cost: $0 per user (vs ~10,000 credits per user with dynamic generation)
 */

// Manifest will be loaded from public/audio/v4/static/manifest.json
// Generated by scripts/generate-static-audio.js
type AudioManifest = {
  [key: string]: {
    filename: string;
    hash: string;
    path: string;
  };
};

export default function V4AudioPreloader() {
  useEffect(() => {
    const preloadStaticAudio = async () => {
      let successCount = 0;
      let skipCount = 0;
      let failCount = 0;

      console.log(`üéµ V4: Starting audio preload from static files...`);

      try {
        // Load the manifest
        const manifestResponse = await fetch('/audio/v4/static/manifest.json');
        
        if (!manifestResponse.ok) {
          console.error('‚ùå Static audio manifest not found. Audio preloading disabled.');
          console.error('   To fix this:');
          console.error('   1. Run: ELEVENLABS_API_KEY=xxx npx tsx scripts/generate-static-audio.js');
          console.error('   2. Commit the generated files');
          console.error('   3. Redeploy');
          // No fallback to dynamic TTS - prevents accidental API charges
          return;
        }

        const manifest: AudioManifest = await manifestResponse.json();
        const manifestKeys = Object.keys(manifest);

        console.log(`üìã Loaded manifest with ${manifestKeys.length} audio files`);

        // Preload each audio file
        for (const [key, audioInfo] of Object.entries(manifest)) {
          const text = V4_STATIC_AUDIO_TEXTS[key as keyof typeof V4_STATIC_AUDIO_TEXTS];
          
          if (!text) {
            console.warn(`‚ö†Ô∏è Unknown key in manifest: ${key}`);
            continue;
          }

          // Skip if already in cache
          if (globalAudioCache.has(text)) {
            skipCount++;
            continue;
          }

          try {
            // Fetch the static audio file
            const audioResponse = await fetch(audioInfo.path);
            
            if (!audioResponse.ok) {
              throw new Error(`Failed to load ${audioInfo.filename}: ${audioResponse.status}`);
            }

            const audioBlob = await audioResponse.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            globalAudioCache.set(text, audioUrl);
            successCount++;
            
            // Log preview of what was cached
            const preview = text.substring(0, 50).replace(/\n/g, ' ');
            const ellipsis = text.length > 50 ? '...' : '';
            console.log(`   ‚úì Cached: "${preview}${ellipsis}"`);
          } catch (err) {
            failCount++;
            const preview = text.substring(0, 50).replace(/\n/g, ' ');
            console.error(`   ‚úó Failed: "${preview}..."`, err);
          }
        }

        console.log(`‚úÖ V4 Audio preload complete!`);
        console.log(`   Successfully cached: ${successCount} segment(s)`);
        console.log(`   Already cached: ${skipCount} segment(s)`);
        console.log(`   Failed: ${failCount} segment(s)`);
        console.log(`   Total cache size: ${globalAudioCache.size()} audio file(s)`);
        console.log(`   üí∞ Cost: $0 (using static files)`);
      } catch (err) {
        console.error('‚ùå Failed to load audio manifest:', err);
        console.error('   Audio preloading disabled - no dynamic TTS fallback (prevents charges)');
        // No fallback to dynamic TTS - prevents accidental API charges
      }
    };

    // Start preloading (static files only - no API fallback)
    preloadStaticAudio();
  }, []); // Empty deps = runs once on mount

  // This component doesn't render anything
  return null;
}

